
# # ----------------------------------------------------------------
# # Course: EECS 110, Northwestern University
# # Term: Winter 2019
# # Autogenerated from: "01. Introduction.ipynb"
# # 
# # Note: Each example is commented out. To uncomment, highlight
# # the area you want to uncomment and type "cmd /" (which both adds
# # and removes comments).
# # ----------------------------------------------------------------




# # --------------------------------------------------------------------------------
# # # FIRST EXAMPLE
# # 1. [Introduction](#1.-Introduction)
# # 2. [First example](#2.-First-Example)
# # 3. [Running the example](#3.-Running-the-Example-with-Jupyter)
# # 4. [Summary](#4.-Summary)
# # --------------------------------------------------------------------------------





# # --------------------------------------------------------------------------------
# # ## 1. Introduction
# # > The following text and example are taken from UC Berkeley's [CS61A course textbook](http://composingprograms.com/pages/11-getting-started.html#programming-in-python), by John DeNero.
# # 
# # In order to define computational processes, we need a programming language; preferably one that many humans and a great variety of computers can all understand. In this text, we will work primarily with the Python language.
# # 
# # Python is a widely used programming language that has recruited enthusiasts from many professions: web programmers, game engineers, scientists, academics, and even designers of new programming languages. When you learn Python, you join a million-person-strong community of developers. Developer communities are tremendously important institutions: members help each other solve problems, share their projects and experiences, and collectively develop software and tools. Dedicated members often achieve celebrity and widespread esteem for their contributions.
# # 
# # The Python language itself is the product of a large volunteer community. The language was conceived and first implemented by Guido van Rossum in the late 1980's. The first chapter of his [Python 3 Tutorial](https://docs.python.org/3/tutorial/appetite.html) explains why Python is so popular, among the many languages available today.
# # 
# # Python excels as an instructional language because, throughout its history, Python's developers have emphasized the human interpretability of Python code, reinforced by the Zen of Python guiding principles of beauty, simplicity, and readability. To view some of Python's guiding principles, simply type `import this` at the Python command prompt.
# # 
# # ```python
# # >>> import this
# # ```
# #     The Zen of Python, by Tim Peters
# #     
# #     Beautiful is better than ugly.
# #     Explicit is better than implicit.
# #     Simple is better than complex.
# #     Complex is better than complicated.
# #     Flat is better than nested.
# #     Sparse is better than dense.
# #     Readability counts.
# #     Special cases aren't special enough to break the rules.
# #     Although practicality beats purity.
# #     Errors should never pass silently.
# #     Unless explicitly silenced.
# #     In the face of ambiguity, refuse the temptation to guess.
# #     There should be one-- and preferably only one --obvious way to do it.
# #     Although that way may not be obvious at first unless you're Dutch.
# #     Now is better than never.
# #     Although never is often better than *right* now.
# #     If the implementation is hard to explain, it's a bad idea.
# #     If the implementation is easy to explain, it may be a good idea.
# #     Namespaces are one honking great idea -- let's do more of those!
# # 
# # 
# # Its broad set of features support a variety of different programming styles, which we will explore. While there is no single way to program in Python, there are a set of conventions shared across the developer community that facilitate reading, understanding, and extending existing programs. Python's combination of great flexibility and accessibility allows students to explore many programming paradigms, and then apply their newly acquired knowledge to thousands of ongoing projects.
# # 
# # The best way to get started programming in Python is to interact with the interpreter directly. This section describes how to install Python 3, initiate an interactive session with the interpreter, and start programming.
# # --------------------------------------------------------------------------------




# # --------------------------------------------------------------------------------
# # ### 1.1. Installing Python 3 (via Anaconda)
# # In this course, you are going to be installing Anaconda â€” a conveniently bundled software package that installs Python 3.7, R, Jupyter Notebook, PIP, Visual Studio Code, and some commonly used Python libraries. Please see the
# # [installation Guide](https://docs.google.com/document/d/1D2Y6u2hZm2zdyLB9IRjrS-IKhDR1v65ZfgxYIVYc0Hk/edit) (i.e. Tutorial 01).
# # 
# # * **Python 3.7**: Software that enables your computer to 'understand' / interpret python files according to a particular language version (in this case 3.7)
# # * **R**: A language and environment for statistical computing and graphics
# # * **Jupyter Notebook**: Software for running and interpreting Jupyter files (a web-based programming environment for Python that makes code and data easier to share).
# # * **PIP**: A package manager (for installing various third-party Python modules).
# # * **Visual Studio Code (VSCode)**: An integrated development environment for creating, editing, and debugging Python programs (and programs in many different languages). An open source project started by Microsoft.
# # --------------------------------------------------------------------------------




# # --------------------------------------------------------------------------------
# # ### 1.2. Interactive Sessions
# # In an interactive Python session (sometimes called **immediate mode**), you type some Python code after the prompt, >>>. The Python interpreter reads and executes what you type, carrying out your various commands.
# # 
# # To start an interactive session, run the Python 3 application. Type **python** at a terminal prompt (Mac/Unix/Linux) or open the Python application in Windows.
# # 
# # If you see the Python prompt, >>>, then you have successfully started an interactive session. These notes depict example interactions using the prompt, followed by some input.
# # 
# # ```python
# # >>> 2 + 2
# # 4
# # ```
# # 
# # **Interactive controls.** Each session keeps a history of what you have typed. To access that history, press Control-P (previous) and Control-N (next). Control-D exits a session, which discards this history. Up and down arrows also cycle through history on some systems.
# # --------------------------------------------------------------------------------




# # --------------------------------------------------------------------------------
# # ### 1.3 Script Mode
# # More commonly, programmers create one or more files, or scripts, that they run. To run a python script at the command line, just type python and then the name of the script:
# # 
# # ```shell
# # $ python my_file.py
# # ```
# # --------------------------------------------------------------------------------




# # --------------------------------------------------------------------------------
# # ## 2. First Example
# # To give Python a proper introduction, we will begin with an example that uses several language features. In the next section, we will start from scratch and build up the language piece by piece. Think of this section as a sneak preview of features to come.
# # 
# # Python has built-in support for a wide range of common programming activities, such as manipulating text, displaying graphics, and communicating over the Internet. The line of Python code
# # 
# # ```python
# # >>> from urllib.request import urlopen
# # ```
# # is an **import** statement that loads functionality for accessing data on the Internet. In particular, it makes available a function called **urlopen**, which can access the content at a uniform resource locator (URL), a location of something on the Internet.
# # --------------------------------------------------------------------------------




# # --------------------------------------------------------------------------------
# # ### 2.1. Statements & Expressions
# # Python code consists of expressions and statements. Broadly, computer programs consist of instructions to either
# # 
# # 1. Compute some value
# # 2. Carry out some action 
# # 
# # Statements typically describe actions. When the Python interpreter executes a statement, it carries out the corresponding action. On the other hand, expressions typically describe computations. When Python evaluates an expression, it computes the value of that expression. This chapter introduces several types of statements and expressions.
# # 
# # The assignment statement
# # 
# # ```python
# # >>> shakespeare = urlopen('http://composingprograms.com/shakespeare.txt') 
# # ```
# # associates the name **shakespeare** with the value of the expression that follows the equal sign (=). That expression applies the **urlopen** function to a URL that contains the complete text of William Shakespeare's 37 plays, all in a single text document.
# # 
# # > **NOTE:** When you enter an expression in an interactive session, Python prints its value on the following line. For instance:
# # >
# # >```python
# # >>>> 2 + 2 / 4
# # >2.5
# # >```
# # --------------------------------------------------------------------------------




# # --------------------------------------------------------------------------------
# # 
# # ### 2.2. Functions
# # Functions encapsulate logic that manipulates data. **urlopen** is a function. A web address is a piece of data, and the text of Shakespeare's plays is another. The process by which the former leads to the latter may be complex, but we can apply that process using only a simple expression because that complexity is tucked away within a function.
# # Another assignment statement
# # 
# # ```python
# # >>> words = set(shakespeare.read().decode().split()) 
# # ```
# # associates the name **words** to the set of all unique words that appear in Shakespeare's plays, all 33,721 of them. The chain of commands to **read**, **decode**, and **split**, each operate on an intermediate computational entity: we read the data from the opened URL, then decode the data into text, and finally split the text into words. All of those words are placed in a **set**.
# # --------------------------------------------------------------------------------




# # --------------------------------------------------------------------------------
# # ### 2.3. Objects
# # A set is a type of object, one that supports set operations like computing intersections and membership. An object seamlessly bundles together data and the logic that manipulates that data, in a way that manages the complexity of both. Everything in Python is an object, and each object **type** has its own unique properties. To find out what data and logic (i.e. attributes and methods) an object possesses, use the **dir** function.
# # 
# # ```python
# # >>> # An object of type "set":
# # >>> type(words)
# # <class 'set'>
# # >>> dir(words)
# # ['__and__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__iand__', '__init__', '__init_subclass__', '__ior__', '__isub__', '__iter__', '__ixor__', '__le__', '__len__', '__lt__', '__ne__', '__new__', '__or__', '__rand__', '__reduce__', '__reduce_ex__', '__repr__', '__ror__', '__rsub__', '__rxor__', '__setattr__', '__sizeof__', '__str__', '__sub__', '__subclasshook__', '__xor__', 'add', 'clear', 'copy', 'difference', 'difference_update', 'discard', 'intersection', 'intersection_update', 'isdisjoint', 'issubset', 'issuperset', 'pop', 'remove', 'symmetric_difference', 'symmetric_difference_update', 'union', 'update']
# # 
# # >>> # An object of type "string":
# # >>> type('Hi there')
# # <class 'str'>
# # >>> dir('Hi there')
# # ['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isascii', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']
# # ```
# # --------------------------------------------------------------------------------




# # --------------------------------------------------------------------------------
# # ## 3. Running the Example with Jupyter
# # In the section below, we will use executable cells to run an example of analyzing words in Shakespeare's plays.
# # ### 3.1. Retrieving and parsing words
# # --------------------------------------------------------------------------------

# from urllib.request import urlopen
# # If you want, feel free to analyze other books via Project Gutenburg:
# # https://www.gutenberg.org
# shakespeare = urlopen('http://composingprograms.com/shakespeare.txt')
# words = shakespeare.read().decode().lower().split()
# 
# # Count all of the words:
# print('The number of total words is:', len(words))
# 
# # print first 20 words of the words list:
# print('\nThe first 20 words are:', words[0:20])
# # get a list of distinct words by converting the list to a set:
# distinct_words = set(words)
# 
# # count all of the distinct words:
# print('\nThe number of distinct words is:', len(distinct_words))



# # --------------------------------------------------------------------------------
# # ### 3.2. Calculating word frequencies
# # What are the 20 most common words? Python modules make it easy to perform calculations
# # that would take longer to program from scratch and / or do manually.
# # --------------------------------------------------------------------------------

# # module that does sequence calculations:
# from collections import Counter
# 
# # prints out the available functions for the Counter class:
# # print(dir(Counter))
# 
# # uses the "most_common" function to print the most common words:
# print('Most common words:\n', Counter(words).most_common(20))
# for pair in Counter(words).most_common(20):
#     print(pair[0], ':', pair[1])



# # --------------------------------------------------------------------------------
# # ### 3.3 Filtering
# # --------------------------------------------------------------------------------

# # create a simple function to get rid of punctuations, articles, conjunctions, etc.
# def filter_out_short_words(word):
#     if len(word) >= 5:
#         return True
#     return False
# 
# # use the built-in filter function with my custom filter to remove words that are less than 5 characters
# big_words = filter(filter_out_short_words, words)
# most_common_20 = Counter(big_words).most_common(20)
# 
# # now find the most commont 20 words
# print('\n\nMost common big words:\n', most_common_20)
# # make more readable:
# for pair in most_common_20:
#     print(pair[0], ':', pair[1])



# # --------------------------------------------------------------------------------
# # ### 3.4. Visualizing the most common words
# # --------------------------------------------------------------------------------

# # get most common n words (feel free to change this number)
# import matplotlib as mpl
# import matplotlib.pyplot as plt
# 
# 
# n = 20
# most_common_reversed = sorted(most_common_20, key=lambda x: x[1])
# 
# # get the words out of the list of tuples
# top_n_words = [n[0] for n in most_common_reversed]
# 
# # get the counts out of the list of tuples
# counts = [n[1] for n in most_common_reversed]
# 
# # draw a bar chart with counts
# bar_width = 0.3
# mpl.rcParams['axes.linewidth'] = 0
# plt.figure(figsize=(10,int(n*bar_width))) # width, height
# plt.barh(top_n_words, counts, align="center", color="#5f3992", alpha=0.5)
# plt.title('\n\nWhat are the top {0} most common words across Shakespeare\'s plays?'.format(n))
# 
# # hide x-axis labels
# frame = plt.gca()
# frame.axes.get_xaxis().set_ticks([])
# 
# # label bar w/count:
# for i, v in enumerate(counts):
#     plt.text(v + 3, i - bar_width/3*2, str(v), color='#444444')
#     
# plt.show()



# # --------------------------------------------------------------------------------
# # ## 4. Summary
# # ### What should I be getting from these examples?
# # The purpose of these examples is to walk you through one Python-based programming 
# # application: analyzing files (i.e. What are the most common words?) and presenting 
# # information in a way that is (hopefully) easier to understand (e.g. graphically). 
# # In doing so, we have used many programming constructs that we will be covering in this 
# # course. Some other important concepts to note:
# # --------------------------------------------------------------------------------




# # --------------------------------------------------------------------------------
# # ### 4.1. Data Types
# # In this example, we worked with a number of different data types. Some are primitive data types (e.g. strings, floats, integers, and booleans). Others are complex data types (lists, sets, tuples). You can also build your own custom types. Some of the data types used are listed below:
# # 
# # <table class="tbl">
# #     <thead>
# #         <tr>
# #             <th>data type</th>
# #             <th>category</th>
# #             <th>description</th>
# #             <th>examples from the code above</th>
# #         </tr>
# #     </thead>
# #     <tbody>
# #         <tr>
# #             <td>string</td>
# #             <td>primitive</td>
# #             <td>A sequence of characters</td>
# #             <td>
# #                 <ul>
# #                     <li>'The number of total words is:'</li>
# #                     <li>words[0]</li>
# #                 </ul>
# #             </td>
# #         </tr>
# #         <tr>
# #             <td>int</td>
# #             <td>primitive</td>
# #             <td>Any integer</td>
# #             <td>
# #                 <ul>
# #                     <li>n</li>
# #                     <li>20</li>
# #                     <li>len(words)</li>
# #                 </ul>
# #             </td>
# #         </tr>
# #         <tr>
# #             <td>float</td>
# #             <td>primitive</td>
# #             <td>Any decimal number</td>
# #             <td>
# #                 <ul>
# #                     <li>bar_width</li>
# #                     <li>0.3</li>
# #                     <li>alpha</li>
# #                 </ul>
# #             </td>
# #         </tr>
# #         <tr>
# #             <td>
# #                 boolean
# #             </td>
# #             <td>
# #                 primitive
# #             </td>
# #             <td>
# #                  true or false
# #             </td>
# #             <td>
# #                 <ul>
# #                     <li>True</li>
# #                     <li>False</li>
# #                     <li>
# #                         len(word) >= 5
# #                         <br>(any expression that evaluates to True or False)
# #                     </li>
# #                 </ul>
# #             </td>
# #         </tr>
# #         <tr>
# #             <td>
# #                 list
# #             </td>
# #             <td>
# #                 complex
# #             </td>
# #             <td>
# #                  A mutable (changable) ordered sequence of elements
# #             </td>
# #             <td>
# #                 <ul>
# #                     <li>words (list of strings)</li>
# #                     <li>top_n_words (list of strings)</li>
# #                     <li>counts (list of ints)</li>
# #                     <li>most_common (list of tuples)</li>
# #                 </ul>
# #             </td>
# #         </tr>
# #         <tr>
# #             <td>
# #                 set
# #             </td>
# #             <td>
# #                 complex
# #             </td>
# #             <td>
# #                  An unordered collection data type that is mutable, and has no duplicate elements
# #             </td>
# #             <td>
# #                  <ul>
# #                     <li>distinct_words</li>
# #                     <li>set(words)</li>
# #                 </ul>
# #             </td>
# #         </tr>
# #         <tr>
# #             <td>
# #                 tuple
# #             </td>
# #             <td>
# #                 complex
# #             </td>
# #             <td>
# #                  Similar to a list except for that tuples cannot be changed (the are immutable), and they use parentheses (whereas lists use square brackets)
# #             </td>
# #             <td>
# #                 most_common[0], most_common_reversed[12]
# #             </td>
# #         </tr>
# #     </tbody>
# # </table>
# # --------------------------------------------------------------------------------




# # --------------------------------------------------------------------------------
# # ### 4.2. Modules
# # Python modules provide high-level functionality so that you don't 
# # have to write as much code from scratch -- particularly for common
# # functionality (like counting, sorting, and filtering things). In 
# # this course, we will use many different kinds of modules in order
# # to take advantage of interesting applications of computer programming.
# # In the examples above, we used the following modules, which we imported:
# # 
# # * `urllib`, which helps you make requests and parse files from URLs
# # * `matplotlib`, which helps you make charts and graphs
# # * `collections`, which helps you perform operations on collections
# # --------------------------------------------------------------------------------




# # --------------------------------------------------------------------------------
# # ### 4.3. Functions
# # #### 4.3.1. Built-in functions
# # Like modules, there are a number of functions that are part of the Python language 
# # that do common things. In this example, the following built-in functions were used:
# # ```python
# # type    # tells you an object's type
# # dir     # tells you the attributes and methods associated with a particular object type
# # len     # calculated the length of a list, set, or string
# # set     # converted a list to an unordered collection of distinct elements
# # filter  # filtered a list according to a filtering function
# # print   # outputted a string to the console
# # sorted  # sorted a list according to a condition that I specificed
# # ```
# # 
# # #### 4.3.2. Custom functions
# # We also made our own filter function in the [filtering](#3.-Filtering) section, where we instantiated a simple rule for filtering out 'junk' words. If a word is at least 5 characters, keep it, otherwise ignore it. In reality, this function would be 'smarter,' but this is just an example. We will learn more about filtering in the second half of the course.
# # 
# # ```python
# # def filter_out_short_words(word):
# #     if len(word) >= 5:
# #         return True
# #     return False
# # ```
# # --------------------------------------------------------------------------------




# # --------------------------------------------------------------------------------
# # ### 4.4. Control
# # Finally (and you probably already noticed), there is a specific order in which the interpreter runs a program. Learning the rules for executing a program in appropriate order is a key learning objective in this course. Code can branch and repeat. It can be executed when particular events are called. We will explore a number of different scenarios.
# # --------------------------------------------------------------------------------

